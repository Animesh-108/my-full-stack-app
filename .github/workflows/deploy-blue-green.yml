name: Deploy App (Blue-Green EKS)

on:
  push:
    branches:
      - main

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      service: ${{ steps.detect.outputs.service }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history to prevent shallow clone issues

      - name: Detect which service changed
        id: detect
        run: |
          echo "üîç Checking which service changed..."
          
          # Use HEAD~1 to get the last commit's changes
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check for backend code OR backend k8s files
          if echo "$CHANGED_FILES" | grep -q -E "^backend/|^k8s/backend-"; then
            echo "‚úÖ Detected backend changes"
            echo "service=backend" >> $GITHUB_OUTPUT
          # Check for frontend code OR frontend k8s files
          elif echo "$CHANGED_FILES" | grep -q -E "^frontend/|^k8s/frontend-"; then
            echo "‚úÖ Detected frontend changes"
            echo "service=frontend" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No service changes detected"
            echo "service=none" >> $GITHUB_OUTPUT
          fi

  build_and_push:
    needs: detect
    if: needs.detect.outputs.service != 'none'
    runs-on: ubuntu-latest
    outputs:
      IMAGE_SHA: ${{ github.sha }}
      SERVICE: ${{ needs.detect.outputs.service }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set Image URI
        id: set-image-uri
        run: |
          if [ "${{ needs.detect.outputs.service }}" = "frontend" ]; then
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_FRONTEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          else
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_BACKEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          fi
      
      - name: Ensure ECR repository exists
        run: |
          if [ "${{ needs.detect.outputs.service }}" = "frontend" ]; then
            REPO_NAME="frontend"
          else
            REPO_NAME="backend"
          fi
          aws ecr describe-repositories --repository-names $REPO_NAME --region ${{ secrets.AWS_REGION }} || \
          aws ecr create-repository --repository-name $REPO_NAME --region ${{ secrets.AWS_REGION }}

      - name: Build and push Docker image
        id: build-image # Give this step an ID
        run: |
          SERVICE="${{ needs.detect.outputs.service }}"
          IMAGE_URI="${{ steps.set-image-uri.outputs.IMAGE_URI }}"
          IMAGE_SHA="${{ github.sha }}"
          
          # Set context path for Docker build
          if [ "$SERVICE" = "frontend" ]; then
            BUILD_CONTEXT="frontend"
          else
            BUILD_CONTEXT="backend"
          fi

          echo "üõ† Building Docker image for $SERVICE..."
          docker build -t "${IMAGE_URI}:${IMAGE_SHA}" -t "${IMAGE_URI}:green" ./${BUILD_CONTEXT}
          
          echo "üì§ Pushing Docker image for $SERVICE..."
          docker push "${IMAGE_URI}:${IMAGE_SHA}"
          docker push "${IMAGE_URI}:green"
          
          # Output the URI for the next job
          echo "::set-output name=IMAGE_URI::${IMAGE_URI}"

  deploy_green:
    needs: build_and_push
    runs-on: ubuntu-latest
    outputs:
      SERVICE: ${{ needs.build_and_push.outputs.SERVICE }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name blue-green-cluster --region "${{ secrets.AWS_REGION }}"

      # Re-create the IMAGE_URI variable securely
      - name: Set Image URI
        id: set-image-uri
        run: |
          if [ "${{ needs.build_and_push.outputs.SERVICE }}" = "frontend" ]; then
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_FRONTEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          else
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_BACKEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to Kubernetes (Green)
        run: |
          SERVICE="${{ needs.build_and_push.outputs.SERVICE }}"
          MANIFEST="k8s/${SERVICE}-green.yaml"
          IMAGE_URI="${{ steps.set-image-uri.outputs.IMAGE_URI }}"
          IMAGE_SHA="${{ needs.build_and_push.outputs.IMAGE_SHA }}"

          echo "üöÄ Deploying ${SERVICE}-green with image ${IMAGE_URI}:${IMAGE_SHA}"
          kubectl apply -f $MANIFEST
          kubectl set image deployment/${SERVICE}-green ${SERVICE}=${IMAGE_URI}:${IMAGE_SHA}

      # --- UPDATED VERIFICATION STEP ---
      - name: Verify Green Deployment Health (with Metrics)
        run: |
          SERVICE="${{ needs.build_and_push.outputs.SERVICE }}"
          echo "üîç Verifying Green deployment health..."
          
          # 1. Initial rollout check (fast)
          kubectl rollout status deployment/${SERVICE}-green --timeout=120s || {
            echo "‚ùå Green deployment failed basic rollout!"
            exit 1
          }

          # Only run advanced metrics check for the backend
          if [ "$SERVICE" = "backend" ]; then
            echo "üî¨ Starting 60-second canary test for backend..."
            
            # Install bc for floating point comparison
            sudo apt-get update && sudo apt-get install -y bc
            
            # Port-forward Prometheus in the background
            # This is simpler than installing promq or curl inside the runner
            echo "Setting up port-forward to Prometheus..."
            kubectl port-forward -n monitoring svc/prometheus-kube-prometheus-prometheus 9090:9090 &
            PROM_PID=$!
            sleep 5 # Give port-forward time to establish
            
            PROM_URL="http://127.0.0.1:9090"

            # Loop for 60 seconds, checking for errors every 10 seconds
            for i in $(seq 1 6); do
              sleep 10
              echo "Checking for 5xx errors... (Check $i of 6)"
              
              # This query looks for any 5xx errors from the 'backend-green' pods in the last minute
              ERROR_QUERY="sum(rate(http_request_duration_seconds_count{status_code=~'5..', job='default/backend-green'}[1m]))"
              
              # Use curl to query Prometheus
              ERROR_RATE=$(curl -s -g "$PROM_URL/api/v1/query" --data-urlencode "query=$ERROR_QUERY" | jq -r '.data.result[0].value[1] // "0"')

              if [ $(echo "$ERROR_RATE > 0" | bc -l) -eq 1 ]; then
                echo "‚ùå Canary test failed! Detected 5xx error rate: $ERROR_RATE"
                kill $PROM_PID # Kill the port-forward process
                exit 1
              else
                echo "‚úÖ No errors detected. (Rate: $ERROR_RATE)"
              fi
            done
            
            echo "‚úÖ Canary test passed! Green deployment is healthy."
            kill $PROM_PID # Kill the port-forward process
          else
            echo "‚úÖ Frontend deployment is ready (skipping advanced metrics)."
          fi

  switch_traffic:
    needs: deploy_green
    runs-on: ubuntu-latest
    environment: production # Pauses for manual approval
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name blue-green-cluster --region "${{ secrets.AWS_REGION }}"

      # Re-create the IMAGE_URI variable securely
      - name: Set Image URI
        id: set-image-uri
        run: |
          if [ "${{ needs.deploy_green.outputs.SERVICE }}" = "frontend" ]; then
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_FRONTEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          else
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_BACKEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          fi

      - name: Switch Traffic (Blue ‚Üí Green)
        run: |
          SERVICE="${{ needs.deploy_green.outputs.SERVICE }}"
          echo "üîÅ Switching traffic to ${SERVICE}-green..."
          kubectl patch svc ${SERVICE}-service -p "{\"spec\":{\"selector\":{\"app\":\"${SERVICE}\",\"version\":\"green\"}}}"
          echo "‚úÖ Traffic switched. Current service status:"
          kubectl get svc ${SERVICE}-service

      - name: Refresh Blue Deployment
        run: |
          SERVICE="${{ needs.deploy_green.outputs.SERVICE }}"
          IMAGE_URI="${{ steps.set-image-uri.outputs.IMAGE_URI }}"
          IMAGE_SHA="${{ needs.build_and_push.outputs.IMAGE_SHA }}"

          echo "‚ôªÔ∏è Refreshing Blue deployment for next cycle..."
          kubectl set image deployment/${SERVICE}-blue ${SERVICE}=${IMAGE_URI}:${IMAGE_SHA}

  cleanup_blue:
    needs: switch_traffic # Only run if the traffic switch was successful
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name blue-green-cluster --region "${{ secrets.AWS_REGION }}"
          
      - name: Scale down Blue deployment
        run: |
          SERVICE="${{ needs.deploy_green.outputs.SERVICE }}"
          echo "‚úÖ Green deployment is live. Scaling down ${SERVICE}-blue to 0 replicas."
          kubectl scale deployment/${SERVICE}-blue --replicas=0