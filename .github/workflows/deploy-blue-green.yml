name: Deploy App (Blue-Green EKS)

on:
  push:
    branches:
      - main

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      service: ${{ steps.detect.outputs.service }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history to prevent shallow clone issues

      - name: Detect which service changed
        id: detect
        run: |
          echo "üîç Checking which service changed..."
          
          # Use HEAD~1 to get the last commit's changes
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check for backend code OR backend k8s files
          if echo "$CHANGED_FILES" | grep -q -E "^backend/|^k8s/backend-"; then
            echo "‚úÖ Detected backend changes"
            echo "service=backend" >> $GITHUB_OUTPUT
          # Check for frontend code OR frontend k8s files
          elif echo "$CHANGED_FILES" | grep -q -E "^frontend/|^k8s/frontend-"; then
            echo "‚úÖ Detected frontend changes"
            echo "service=frontend" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No service changes detected"
            echo "service=none" >> $GITHUB_OUTPUT
          fi

  build_and_push:
    needs: detect
    if: needs.detect.outputs.service != 'none'
    runs-on: ubuntu-latest
    # Pass the image URI and SHA to downstream jobs
    outputs:
      IMAGE_URI: ${{ steps.set-image-uri.outputs.IMAGE_URI }}
      IMAGE_SHA: ${{ github.sha }}
      SERVICE: ${{ needs.detect.outputs.service }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set Image URI
        id: set-image-uri
        run: |
          if [ "${{ needs.detect.outputs.service }}" = "frontend" ]; then
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_FRONTEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          else
            echo "IMAGE_URI=$(echo "${{ secrets.ECR_REPO_BACKEND }}" | tr -d '\n\r')" >> $GITHUB_OUTPUT
          fi
      
      - name: Ensure ECR repository exists
        run: |
          if [ "${{ needs.detect.outputs.service }}" = "frontend" ]; then
            REPO_NAME="frontend"
          else
            REPO_NAME="backend"
          fi
          aws ecr describe-repositories --repository-names $REPO_NAME --region ${{ secrets.AWS_REGION }} || \
          aws ecr create-repository --repository-name $REPO_NAME --region ${{ secrets.AWS_REGION }}

      - name: Build and push Docker image
        run: |
          SERVICE="${{ needs.detect.outputs.service }}"
          IMAGE_URI="${{ steps.set-image-uri.outputs.IMAGE_URI }}"
          IMAGE_SHA="${{ github.sha }}"
          
          # Set context path for Docker build
          if [ "$SERVICE" = "frontend" ]; then
            BUILD_CONTEXT="frontend"
          else
            BUILD_CONTEXT="backend"
          fi

          echo "üõ† Building Docker image for $SERVICE..."
          docker build -t "${IMAGE_URI}:${IMAGE_SHA}" -t "${IMAGE_URI}:green" ./${BUILD_CONTEXT}
          
          echo "üì§ Pushing Docker image for $SERVICE..."
          docker push "${IMAGE_URI}:${IMAGE_SHA}"
          docker push "${IMAGE_URI}:green"

  deploy_green:
    needs: build_and_push
    runs-on: ubuntu-latest
    # Pass service name to the next job
    outputs:
      SERVICE: ${{ needs.build_and_push.outputs.SERVICE }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name blue-green-cluster --region "${{ secrets.AWS_REGION }}"

      - name: Deploy to Kubernetes (Green)
        run: |
          SERVICE="${{ needs.build_and_push.outputs.SERVICE }}"
          MANIFEST="k8s/${SERVICE}-green.yaml"
          IMAGE_URI="${{ needs.build_and_push.outputs.IMAGE_URI }}"
          IMAGE_SHA="${{ needs.build_and_push.outputs.IMAGE_SHA }}"

          echo "üöÄ Deploying ${SERVICE}-green with image ${IMAGE_URI}:${IMAGE_SHA}"
          kubectl apply -f $MANIFEST
          kubectl set image deployment/${SERVICE}-green ${SERVICE}=${IMAGE_URI}:${IMAGE_SHA}

      - name: Verify Green Deployment Health
        run: |
          SERVICE="${{ needs.build_and_push.outputs.SERVICE }}"
          echo "üîç Verifying Green deployment health..."
          # This is your automatic health check
          kubectl rollout status deployment/${SERVICE}-green --timeout=120s || {
            echo "‚ùå Green deployment failed health checks!"
            # No rollback needed here, as traffic was never switched
            exit 1
          }

  switch_traffic:
    needs: deploy_green
    runs-on: ubuntu-latest
    # This key links the job to your protected environment
    # The job will PAUSE here and wait for your approval
    environment: production 
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name blue-green-cluster --region "${{ secrets.AWS_REGION }}"

      - name: Switch Traffic (Blue ‚Üí Green)
        run: |
          SERVICE="${{ needs.deploy_green.outputs.SERVICE }}"
          echo "üîÅ Switching traffic to ${SERVICE}-green..."
          kubectl patch svc ${SERVICE}-service -p "{\"spec\":{\"selector\":{\"app\":\"${SERVICE}\",\"version\":\"green\"}}}"
          echo "‚úÖ Traffic switched. Current service status:"
          kubectl get svc ${SERVICE}-service

      - name: Refresh Blue Deployment
        run: |
          SERVICE="${{ needs.deploy_green.outputs.SERVICE }}"
          IMAGE_URI="${{ needs.build_and_push.outputs.IMAGE_URI }}"
          IMAGE_SHA="${{ needs.build_and_push.outputs.IMAGE_SHA }}"

          echo "‚ôªÔ∏è Refreshing Blue deployment for next cycle..."
          kubectl set image deployment/${SERVICE}-blue ${SERVICE}=${IMAGE_URI}:${IMAGE_SHA}